# -*- coding: utf-8 -*-
"""Global_alignment and local alignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zTEd-vHtymAyWEjLlKlnXMy81XWlJb18
"""

#!/usr/bin/env python
import numpy as np

seq_2 = "GAATC"
seq_1 = "CATAC"

# A:A, C:C, etc get +1
# any mismatch gets -1
subst_matrix = {
'A': {'A': 10,'C':-5,'G':0,'T':-5},
'C': {'A':-5,'C': 10,'G':-5,'T':0},
'G': {'A':0,'C':-5,'G': 10,'T':-5},
'T': {'A':-5,'C':0,'G':-5,'T': 10},
}
coordinates=["g,c","a,c","a,c","t,c","c,c","g,a","a,a","a,a","t,a","c,a","g,t","a,t","a,t","t,t","c,t","g,a","a,a","a,a","t,a","c,a","g,c","a,c","a,c","t,c","c,c"]
gap_penalty = -4
directions={}
steps=[]
# this will store our dynamic programming matrix
dp_matrix = np.ndarray(shape=(len(seq_1)+1,len(seq_2)+1), dtype=int)
dp_matrix.fill(0)
diagonal={}
count=0
# fill the DP matrix
for i in range(len(seq_1)+1):
    for j in range(len(seq_2)+1):
        if i==0 and j==0: continue # skip the first cell

        char_1 = seq_1[i-1] # current character at seq 1
        char_2 = seq_2[j-1] # current character at seq 2

        #
        # YOUR TASK: 'scores' must be filled in here
	# HINTS:
	#  * refer to the previous (e.g. diagonal predecessor) cell as dp_matrix[i-1,j-1]
	#  * get the substitution score as subst_matrix[char_1][char_2]
        #  * the gap score is called gap_penalty (these variables are defined above)
	#
        scores = [-999,-999,-999]
        if( i>0 and j>0 ):
#             # score diagonal
            scores[0] = dp_matrix[i-1,j-1] + subst_matrix[char_1][char_2]
            directions["diagonal"]=dp_matrix[i-1,j-1] + subst_matrix[char_1][char_2]
#         for keys in diagonal:
#             diagonal[scores[0]]='d'
#             print("ll",diagonal)

            #print("diagonal/////",scores[0])
            #print(diagonal)
            pass
        if( i>0 ):
            # score up: gap in sequence 2
            scores[1] = dp_matrix[i-1,j] + gap_penalty
            directions["up"]=dp_matrix[i-1,j] + gap_penalty
            #for i in (scores)
            #print("up/////",scores[1])
            pass
        if( j>0 ):
            # score left: gap in sequence 1
            scores[2] = dp_matrix[i,j-1] + gap_penalty
            directions["left"]=dp_matrix[i,j-1] + gap_penalty
            #print("left/////",scores[2])
            pass
        MAX=-9000
        for z in directions:
            if(directions[z]>MAX):
                MAX=directions[z]
        for zz , jj in directions.items():
            if (jj == MAX):
                steps.append(zz)
        print(scores)
        #print(scores[0],scores[1],scores[2],"g,c")
        # select the best previous cell
        difference=scores[0]-scores[1]-scores[2]
        #if ((scores[0] == scores[2]) or (scores[0]==scores[1]):
        best = max(scores)
        dp_matrix[i,j]=best
#         if (difference < -800):
#             continue
#         else:
#             best_index=max(scores)
#             INDEX=scores.index(best_index)
#             if (INDEX==0):
#                 directions.append("diagonal")
#             elif(INDEX==1):
#                 directions.append("up")
#             elif(INDEX==2):
#                 directions.append("Left")
        #best = max(scores)
        count+=1
#         for i in best:
#             diagonal[i]=coordinates[i]
        #dp_matrix[i,j]=best
#print("ll",diagonal)
#print("////",diagonal)
print("Dynamic programming matrix:")
print(dp_matrix)
print(directions)
print("///////////")
print(len(directions))
print(count)


print(steps)
print("len",len(steps))
# Best score for global allignment

print("best sore",best)

seq_2 = "GAATC"
seq_1 = "CATAC"

"""# LOCAL ALLIGNMENT"""

#!/usr/bin/env python
import numpy as np

seq_2 = "GAATC"
seq_1 = "CATAC"

# A:A, C:C, etc get +1
# any mismatch gets -1
subst_matrix = {
'A': {'A': 10,'C':-5,'G':0,'T':-5},
'C': {'A':-5,'C': 10,'G':-5,'T':0},
'G': {'A':0,'C':-5,'G': 10,'T':-5},
'T': {'A':-5,'C':0,'G':-5,'T': 10},
}
gap_penalty = -4
directions={}
steps=[]

# this will store our dynamic programming matrix
dp_matrix = np.ndarray(shape=(len(seq_1)+1,len(seq_2)+1), dtype=int)
dp_matrix.fill(0)


# fill the DP matrix
for i in range(len(seq_1)+1):
    for j in range(len(seq_2)+1):
        if i==0 and j==0: continue # skip the first cell

        char_1 = seq_1[i-1] # current character at seq 1
        char_2 = seq_2[j-1] # current character at seq 2

        #
        # YOUR TASK: 'scores' must be filled in here
	# HINTS:
	#  * refer to the previous (e.g. diagonal predecessor) cell as dp_matrix[i-1,j-1]
	#  * get the substitution score as subst_matrix[char_1][char_2]
        #  * the gap score is called gap_penalty (these variables are defined above)
	#
        scores = [-999,-999,-999,0]
        if( i>0 and j>0 ):
#             # score diagonal
            scores[0] = dp_matrix[i-1,j-1] + subst_matrix[char_1][char_2]
            directions["diagonal"]=dp_matrix[i-1,j-1] + subst_matrix[char_1][char_2]
            pass
        if( i>0 ):
            # score up: gap in sequence 2
            scores[1] = dp_matrix[i-1,j] + gap_penalty
            directions["up"]=dp_matrix[i-1,j] + gap_penalty
            pass
        if( j>0 ):
            # score left: gap in sequence 1
            scores[2] = dp_matrix[i,j-1] + gap_penalty
            directions["left"]=dp_matrix[i,j-1] + gap_penalty
            pass
            MAX=-9000
        for z in directions:
            if(directions[z]>MAX):
                MAX=directions[z]
        for zz , jj in directions.items():
            if (jj == MAX):
                steps.append(zz)
        print(scores)
        # select the best previous cell
        best = max(scores)
        dp_matrix[i,j]=best
#         if (best < 0):
#             best = 0
print("Dynamic programming matrix:")
print(dp_matrix)

# best score for local allignment
print(steps)
print("best score",best)

seq_2 = "GAATC"
seq_1 = "CATAC"

"""## understand the above code"""

# to understand char_1, skip the first cell which filled by zero and begin with the real sequence
for j in range(len(seq_2)+1):
    if j==0: continue # skip the first cell

    char_1 = seq_2[j-1] # current character at seq 1
    print(char_1)

# to understand the substitution matrix of char_1, skip the first cell which filled by zero and begin with the real sequence
for j in range(len(seq_2)+1):
    if j==0: continue # skip the first cell

    char_1 = seq_2[j-1] # current character at seq 1
    print(char_1)
    print(subst_matrix[char_1])

# determine ch_1 and ch_2 in substitution matrix
for i in range(len(seq_1)+1):
    for j in range(len(seq_2)+1):
#         if i==0 and j>0: dp_matrix[i,j*gap_penalty]
#         if i>0 and j==0: dp_matrix[i*gap_penalty,j]
        if i==0 and j==0: continue # skip the first cell
        char_1 = seq_1[i-1] # current character at seq 1
        char_2 = seq_2[j-1] # current character at seq 2
        print(char_1,char_2)
        print(subst_matrix[char_1][char_2])